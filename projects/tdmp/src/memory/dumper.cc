#include "pch.h"
#include "memory/dumper.h"
#include "memory/memory.h"
#include "util.h"

using namespace tdmp;

constexpr const char* headerTemplate = R"(#ifndef TDMP_GENERATED_OFFSETS_H
#define TDMP_GENERATED_OFFSETS_H

// Generated by dumper.cc
// Date: {0}
// Time: {1}

#include "offsets_generated_prerequisite.h"

namespace tdmp {{
    namespace offsets {{
{2}        inline bool generate(std::vector<std::string>& failedOffsets) {{
            console::writeln("Function Addresses:");

{3}
            return failedOffsets.size() == 0;
        }}
    }}

    namespace funcs {{
        namespace types {{
{4}        }}

{5}
        inline bool assign() {{
            console::writeln("Assigning functions");

{6}
            return true;
        }}
    }}
}}

#endif // TDMP_GENERATED_OFFSETS_H)";

static void processSignature(const std::string& nsName, const dumper::dumper_signature& sig,
                             std::stringstream& offsets, std::stringstream& checks,
                             std::stringstream& types, std::stringstream& functions,
                             std::stringstream& assignFuncs) {
    const uint64_t address = mem::findIDAPattern(sig.sig, false);
    const uint64_t offsetFromBase = address - mem::baseAddress;

    console::setStatus("Generating offset {} {:#x}", sig.name, offsetFromBase);

    std::string offsetStr = std::format("{:#x}", offsetFromBase);
    offsets << std::format("            inline uint64_t {0} = {1};\n", sig.name, offsetStr);

    checks << std::format("            SET_AND_CHECK_OFFSET({0}::{1}, \"{0}::{1}\");\n", nsName, sig.name);
    assignFuncs << std::format("            ASSIGN_FUNCTION({0}, {1});\n", nsName, sig.name);

    console::writeln("{}::{} = {:#x}", nsName, sig.name, offsetFromBase);

    if (sig.function.has_value()) {
        dumper::function_type func = sig.function.value();
        types << std::format("                using t{0} = std::add_pointer_t<{1}({2})>;\n",
                             sig.name, func.returnType, func.arguments);
        functions << std::format("            static types::{0}::t{1} {1} = nullptr;\n", nsName, sig.name);
    }
}

static void generateTemplate(const dumper::signature_namespace* signatureNamespaces, size_t namespaceCount,
                             std::stringstream& offsets, std::stringstream& checks,
                             std::stringstream& types, std::stringstream& functions,
                             std::stringstream& assignFuncs) {
    for (size_t i = 0; i < namespaceCount; ++i) {
        const auto& ns = signatureNamespaces[i];
        offsets << std::format("        namespace {0} {{\n", ns.name);
        types << std::format("            namespace {0} {{\n", ns.name);
        functions << std::format("        namespace {0} {{\n", ns.name);

        for (const auto& sig : ns.signatures) {
            processSignature(ns.name, sig, offsets, checks, types, functions, assignFuncs);
        }

        offsets << "        }\n\n";
        types << "            }\n\n";
        functions << "        }\n\n";
    }
}


// Public Functions
//------------------------------------------------------------------------
bool dumper::dump() {
    std::stringstream offsets, checks, types, functions, assignFuncs;

    generateTemplate(signatureNamespaces, std::size(signatureNamespaces), offsets, checks, types, functions, assignFuncs);

    std::string result = std::format(headerTemplate,
                                     __DATE__,
                                     __TIME__,
                                     offsets.str(),
                                     checks.str(),
                                     types.str(),
                                     functions.str(),
                                     assignFuncs.str());

    console::writeln("\n{}", result);
    util::copyToClipboard(result);

    return true;
}

bool mem::isAddressExecutable(uintptr_t address) {
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery((void*)address, &mbi, sizeof(mbi))) {
        return (mbi.Protect & PAGE_EXECUTE_READ) ||
            (mbi.Protect & PAGE_EXECUTE_READWRITE) ||
            (mbi.Protect & PAGE_EXECUTE_WRITECOPY);
    }

    return false;
}