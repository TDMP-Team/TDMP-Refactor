#include "pch.h"
#include "memory/memory.h"
#include "util/util.h"

using namespace tdmp;

struct function_type {
    const char* returnType;
    const char* arguments;

    constexpr function_type() = default;
    constexpr function_type(const char* r, const char* a) : returnType(r), arguments(a) {}
};

struct dumper_signature {
    const char* name;
    const char* sig;
    std::optional <function_type> function;

    constexpr dumper_signature(const char* n, const char* s, std::optional<function_type> optFunction = std::nullopt) : name(n), sig(s), function(optFunction) {}
};

//struct signature_group {
//    const char* name;
//    std::span<const dumper_signature> signatures;
//};

struct signature_namespace {
    const char* name;
    std::span<const dumper_signature> signatures;
};

// Lua Signatures
//------------------------------------------------------------------------
static constexpr dumper_signature luaSignatures[] = {
    {"lua_newstate", "E8 ? ? ? ? 48 8B 4B 30 48 89 01", function_type("lua_State*", "lua_Alloc f, void* ud")}
};

// Game Signatures
//------------------------------------------------------------------------
static constexpr dumper_signature gameSignatures[] = {
    {"log", "E8 ? ? ? ? 3B 37", function_type("void", "log_level level, const char* fmt, ..." )}
};

static constexpr dumper_signature tdSignatures[] = {
    { "initialize",
        "4C 89 44 24 18 48 89 4C 24 08 55 53 56 57 41 54 41 55 41 56 41 57 48 8D 6C",
        function_type("structures::teardown*", "structures::teardown* magicShit, DWORD** a2, int64_t a3")
    }
};

static constexpr dumper_signature registrySignatures[] = {
    { "getInt",
        "40 53 48 83 EC 40 45 33 C0 E8 ?? ?? ?? ?? 48 8D 4C 24 20 48 85 C0 74 0B 48 8D 50 28 E8 ?? ?? ?? ?? EB 06 E8 ?? ?? ?? ?? 90 48 8D 4C",
        function_type("int", "uint8_t** a1, uint8_t** a2")
    }
};

static constexpr dumper_signature smallStringSignatures[] = {
    { "fromCString",
        "48 89 5C 24 08 48 89 6C 24 10 48 89 74 24 18 57 48 83 EC 20 48 85 D2 C6",
        function_type("structures::small_string*", "structures::small_string* ss, const char* src")
    },
    { "free",
        "48 83 EC 28 80 79 1F 00 74 09",
        function_type("void", "structures::small_string* ss")
    }
};

// All Signatures
//------------------------------------------------------------------------
#define ADD_NAMESAPCE(name, arr) {##name, {arr, sizeof(arr) / sizeof(arr[0])}}

static constexpr signature_namespace signatureNamespaces[] = {
    ADD_NAMESAPCE("lua", luaSignatures),
    ADD_NAMESAPCE("game", gameSignatures),
    ADD_NAMESAPCE("teardown", tdSignatures),
    ADD_NAMESAPCE("registry", registrySignatures),
    ADD_NAMESAPCE("small_string", smallStringSignatures)
};

static void generateHeaderStart(std::stringstream& header) {
    header <<
        "#ifndef TDMP_GENERATED_OFFSETS_H\n"
        << "#define TDMP_GENERATED_OFFSETS_H\n\n"

        << "// Generated by dumper.cc\n// Date: " << __DATE__ << "\n// Time: " << __TIME__ << "\n\n"

        << "#include \"offsets_generated_prerequisite.h\"\n\n"

        << "namespace tdmp {\n\n"
        << "    namespace offsets {\n";
}

static void generateFunctionStart(std::stringstream& genFuncSS) {
    genFuncSS << "        inline bool generate(std::vector<std::string>& failedOffsets) {\n"
              << "            console::writeln(\"Offsets:\");\n\n";
}

static void processSignature(const std::string& nsName, const dumper_signature& sig, std::stringstream& header, std::stringstream& genFuncSS, std::stringstream& typeSS, std::stringstream& funcDefSS, std::vector<std::string>& invalidSignatures) {
    const uint64_t address = mem::findIDAPattern(sig.sig, false);
    const uint64_t offsetFromBase = address - mem::baseAddress;

    console::setStatus("Generating offset {} {:#x}", sig.name, offsetFromBase);

    if (!address) {
        invalidSignatures.emplace_back(nsName + "::" + sig.name);
    } else {
        std::string formattedLine = std::format("            SET_AND_CHECK_OFFSET({}, \"{}\");\n",
                                                nsName + "::" + sig.name,
                                                nsName + "::" + sig.name);
        genFuncSS << formattedLine;
    }

    console::writeln("{}::{} = {:#x}", nsName, sig.name, offsetFromBase);

    std::string offsetStr = std::format("{:#x}", offsetFromBase);
    header << "            inline uint64_t " << sig.name << " = " << offsetStr << ";";

    if (sig.function.has_value()) {
        function_type func = sig.function.value();

        header << " // " << func.returnType << " " << func.arguments;
    }

    header << '\n';

    // Types
    if (sig.function.has_value()) {
        function_type func = sig.function.value();
        typeSS << "                using t" << sig.name << " = std::add_pointer_t<" << func.returnType << '(' << func.arguments << ")>;\n";
        funcDefSS << "        static types::" << nsName << "::t" << sig.name << ' ' << sig.name << " = nullptr;\n";
    }
}

static void processNamespace(const signature_namespace& ns, std::stringstream& header, std::stringstream& genFuncSS, std::stringstream& typeSS, std::stringstream& funcDefSS, std::vector<std::string>& invalidSignatures) {
    std::string nsName = ns.name;

    std::stringstream tempTypeSS;
    std::stringstream tempFuncDefSS;

    header << "        namespace " << nsName << " {\n";

    for (const auto& sig : ns.signatures) {
        processSignature(nsName, sig, header, genFuncSS, tempTypeSS, tempFuncDefSS, invalidSignatures);
    }

    header << "        }\n\n";

    // Only add to typeSS and funcDefSS if there's content
    if (tempTypeSS.str().length() > 0) {
        typeSS << "            namespace " << nsName << " {\n";
        typeSS << tempTypeSS.str();
        typeSS << "            }\n\n";
    }

    if (tempFuncDefSS.str().length() > 0) {
        funcDefSS << "        namespace " << nsName << " {\n";
        funcDefSS << tempFuncDefSS.str();
        funcDefSS << "        }\n\n";
    }
}

static void generateHeaderEnd(std::stringstream& header, std::stringstream& genFuncSS, std::stringstream& typeSS, std::stringstream& funcDefSS) {
    genFuncSS << "\n            return failedOffsets.size() == 0;\n"
              << "        }\n";
    header << genFuncSS.str() << '\n';

    header << "    }\n\n    namespace funcs {\n\n"
        << "        namespace types {\n";
    header << typeSS.str() << "\n    }\n\n        ";

    header << funcDefSS.str() << '\n';

    header << "    }\n\n}\n\n"
        << "#endif // TDMP_GENERATED_OFFSETS_H";
}

static void copyToClipboard(const std::string& text) {
    HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, text.length() + 1);
    if (!hMem) {
        util::displayLastError(L"copyToClipboard failed, could not allocate memory");
        return;
    }

    LPVOID locked = GlobalLock(hMem);
    if (!locked) {
        util::displayLastError(L"Could not lock memory in copyToClipboard");
        GlobalFree(hMem);
        return;
    }

    memcpy(locked, text.data(), text.length() + 1);
    GlobalUnlock(hMem);
    OpenClipboard(0);
    EmptyClipboard();
    SetClipboardData(CF_TEXT, hMem);
    CloseClipboard();

    GlobalFree(hMem);

    util::displayMessage(MB_OK, L"Copied generated offsets to clipboard!");
}

bool mem::dumpOffsets() {
    std::vector<std::string> invalidSignatures;
    std::stringstream header, genFuncSS, typeSS, funcDefSS;

    generateHeaderStart(header);
    generateFunctionStart(genFuncSS);

    for (const auto& ns : signatureNamespaces) {
        processNamespace(ns, header, genFuncSS, typeSS, funcDefSS, invalidSignatures);
    }

    generateHeaderEnd(header, genFuncSS, typeSS, funcDefSS);

    std::string finalString = header.str();
    console::writeln("\n{}", finalString);

    // Display result
    if (!invalidSignatures.empty()) {
        console::writeln("Failed getting offsets, invalid signatures are:");
        for (const std::string& name : invalidSignatures) {
            console::writeln("    {}", name);
        }
    }

    copyToClipboard(finalString);

    return true;
}

bool mem::isAddressExecutable(uintptr_t address) {
    MEMORY_BASIC_INFORMATION mbi;
    if (VirtualQuery((void*)address, &mbi, sizeof(mbi))) {
        return (mbi.Protect & PAGE_EXECUTE_READ) ||
            (mbi.Protect & PAGE_EXECUTE_READWRITE) ||
            (mbi.Protect & PAGE_EXECUTE_WRITECOPY);
    }
    return false;
}