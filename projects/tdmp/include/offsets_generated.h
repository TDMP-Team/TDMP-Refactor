#ifndef TDMP_GENERATED_OFFSETS_H
#define TDMP_GENERATED_OFFSETS_H

// Generated by dumper.cc
// Date: Jun 27 2024
// Time: 14:51:04

#include "util/util.h"
#include "memory/memory.h"

#define SET_AND_CHECK_OFFSET(addr, addr_name) \
    do { \
        addr = mem::baseAddress + addr; \
        console::writeln("  {} = 0x{:X}", addr_name, addr); \
        if (!mem::isAddressExecutable(addr)) { \
            failedOffsets.push_back(addr_name); \
        } \
    } while (0)

namespace tdmp::offsets {

    namespace lua {
        inline uint64_t lua_newstate = 0x39b360;
    }

    namespace game {
        inline uint64_t log = 0x408b10;
    }

    namespace teardown {
        inline uint64_t initialize = 0x5a5b0;
    }

    namespace registry {
        inline uint64_t getInt = 0x1fffb0;
    }

    namespace small_string {
        inline uint64_t fromCString = 0x289430;
        inline uint64_t free = 0x2895a0;
    }

    inline bool generate(std::vector<std::string>& failedOffsets) {
        console::writeln("Offsets:");

        SET_AND_CHECK_OFFSET(lua::lua_newstate, "lua::lua_newstate");
        SET_AND_CHECK_OFFSET(game::log, "game::log");
        SET_AND_CHECK_OFFSET(teardown::initialize, "teardown::initialize");
        SET_AND_CHECK_OFFSET(registry::getInt, "registry::getInt");
        SET_AND_CHECK_OFFSET(small_string::fromCString, "small_string::fromCString");
        SET_AND_CHECK_OFFSET(small_string::free, "small_string::free");

        return failedOffsets.size() == 0;
    }

}

#endif // TDMP_GENERATED_OFFSETS_H